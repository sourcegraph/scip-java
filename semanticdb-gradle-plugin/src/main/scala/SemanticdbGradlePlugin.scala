package com.sourcegraph.gradle.semanticdb

import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.tasks.compile.JavaCompile
import org.gradle.api.tasks.scala.ScalaCompile
import org.gradle.api.artifacts.component.ModuleComponentIdentifier
import com.sourcegraph.scip_java.BuildInfo
import org.gradle.api.artifacts.Dependency

class SemanticdbGradlePlugin extends Plugin[Project] {
  override def apply(project: Project) = {
    project.afterEvaluate { project =>
      project.getRepositories().add(project.getRepositories().mavenCentral())

      println(project.getName())
      println(project.getPlugins())

      val targetRoot = project
        .getRootDir()
        .toPath
        .resolve("semanticdb-targetroot")
      val sourceRoot = project.getRootDir()

      if (project.getPlugins().hasPlugin("java")) {

        val javacPluginVersion = "0.8.18" //BuildInfo.version
        project
          .getDependencies()
          .add(
            "compileOnly",
            s"com.sourcegraph:semanticdb-javac:${javacPluginVersion}"
          )
        project
          .getDependencies()
          .add(
            "testCompileOnly",
            s"com.sourcegraph:semanticdb-javac:${javacPluginVersion}"
          )

        project
          .getTasks()
          .withType(classOf[JavaCompile])
          .configureEach { task =>
            // task.doFirst { task =>
            println(
              "Performing some setup before any other plugins are applied..."
            )

            // println(task.getToolChain())
            // if (!metadata.javaRuntimeVersion.startsWith("1.8")) {

            //     val version = Version.parse(metadata.javaRuntimeVersion)
            //     if (version.feature() >= 17) {
            //         if (task.options.forkOptions.jvmArgs != null) {
            //             task.options.forkOptions.jvmArgs!!.addAll(PluginConfig.javacModuleExports)
            //         } else {
            //             task.options.forkOptions.jvmArgs = PluginConfig.javacModuleExports.toList()
            //         }
            //     }
            // }
            // task.options.fork(emptyMap())
            // task.options.compilerArgs.add("-Xplugin:semanticdb -targetroot:$targetRoot -sourceroot:$sourceRoot")
            // }

            task.getOptions().setFork(true)
            task
              .getOptions()
              .getCompilerArgs()
              .add(
                s"-Xplugin:semanticdb -targetroot:$targetRoot -sourceroot:$sourceRoot"
              )

          }
      }

      project
        .getTasks()
        .withType(classOf[ScalaCompile])
        .configureEach { task =>
          // Detect scala version
          var foundScalaVersion = Option.empty[String]
          project
            .getConfigurations()
            .forEach { conf =>
              if (conf.isCanBeResolved() && conf.getName != "zinc") {
                conf
                  .getIncoming()
                  .artifactView(view => view.lenient(true))
                  .getArtifacts()
                  .forEach { artif =>
                    val id = artif.getId().getComponentIdentifier()
                    id match {
                      case id: ModuleComponentIdentifier =>
                        if (
                          id.getGroup() == "org.scala-lang" &&
                          id.getModule() == "scala-library"
                        )
                          foundScalaVersion = Some(id.getVersion())
                      case _ =>
                    }
                  }
              }
            }

          val scalaVersion = foundScalaVersion.get

          val semanticdbVersion = BuildInfo
            .semanticdbScalacVersions(scalaVersion)
          val semanticdbScalacDependency =
            s"org.scalameta:semanticdb-scalac_$scalaVersion:$semanticdbVersion"

          import scala.jdk.CollectionConverters._
          val semanticdbScalac =
            project
              .getConfigurations()
              .detachedConfiguration(
                project.getDependencies.create(semanticdbScalacDependency)
              )
              .getFiles()
              .asScala
              .toList
              .head

          val args = java
            .util
            .List
            .of(
              s"-Xplugin:$semanticdbScalac",
              "-P:semanticdb:sourceroot:$sourceRoot",
              "-P:semanticdb:targetroot:$targetRoot",
              "-P:semanticdb:exclude:(src/play/twirl|src/play/routes)", // Ignore autogenerated Playframework files
              "-P:semanticdb:failures:warning",
              "-Xplugin-require:semanticdb"
            )

          val scalaCompileOptions = task.getScalaCompileOptions()

          if (scalaCompileOptions.getAdditionalParameters == null)
            scalaCompileOptions.setAdditionalParameters(args)
          else
            scalaCompileOptions.getAdditionalParameters.addAll(args)

        }

      println(targetRoot)
    }
  }
}
